# 晓萌机器人团队开发者日志

---
## 2015.6.5

**完成：**<br>
1、今天我把自己负责的有关机械臂的ROS代码按照代码规范进行了适当整理。自己的那部分感觉完成度还不错，但发现了几个比较麻烦的问题，不知道如何去解决。我先记录下来，以后这些问题需要开会时大家互相讨论一下。<br>

**问题：**<br>
1、其他队员的ROS包和代码的命名方式不是很合适，没有按照制定的规范来。要是进行修改的话，必然会牵涉到其他与之有依赖关系的ROS包和代码的修改，工作量还是非常大的。<br>
2、从ROS官网上下载下来的包是否要进行重新的命名？<br>
3、相同类型或是拥有相近功能的ROS包的重命名以及管理问题。<br>

**计划：**<br>
1、了解机械臂与下位机的通信方式，自己写个串口程序来进行验证。<br>
2、深入学习ROS中的ros_control的原理，尽早改好代码！！！<br>
3、快速入门Git，掌握最基本的代码版本控制。<br>

---
## 2015.6.6

**完成：**<br>
1、今天晚上开始学习ros_control，主要是看了ros_control的Wiki介绍以及GitHub上有关ros_control的教程。Wiki上那张ros_control的工作原理流程图，经过自己的反复研究后，终于搞明白了其中的意思。首先，我们需要自己编写一个Controller，让它实现一个接口，比如说是EffortJointInterface类型的接口，这样系统的Controller Manager就可以将它载入到其中并且对它进行相应的控制。下一步就是让Controller与Hardware进行交互。ROS中有一个RobotHW的类，它是硬件接口中非常重要的类。通过它，我们可以让Controller Manager运行相应的Controller间接地来获取最新的关节的位置、速度、力等状态，并且可以发送命令给需要的变量。不过在Controller初始化的时候是需要一些来自硬件接口的Resources。这些Resources可以是关节的名字或是其他的东西，它们能够被Controller Manager所记录，因此Controller Manager可以根据Controller的需求，为它们载入Resources。最后在硬件接口中还有一个最重要的东西就是transmission_interface，它最主要的工作就是能双向地在Actuator与Joint Space中传递数据。简单来说，就是通过这个接口我们可以直接读取电机的位置、速度、力等状态信息，并且发送关节的位置信息。当然，以上的所有工作都只是在软件层面的，要想真正地控制下位机，就还需要write()和read()函数来实现数据的发布与订阅。通过串口等传输协议，将必要的数据发给嵌入式Controller，再由其控制实体的电机。而安装电机上的反馈装置，比如说底盘的编码器能把里程计信息反馈给上层的Controller。这样，一个完整的闭环控制系统就算是搭建起来了。<br>

**问题：**<br>
1、自己在看GitHub上的教程代码时，有些头文件的功能还不是很了解。还有就是有些ROS中的函数的用法还是比较陌生，函数的形参很多，不是很好记住。<br>

**计划：**<br>
1、因为Controller最终是要控制下位机的，所以下一步是学会星爷的串口程序。<br>
2、复习一下Boost库和STL库的用法，重点是Boost。<br>

---
## 2015.6.7

**完成：**<br>
1、我今天在基地主要是学习了星爷写的串口程序，由于程序中用了很多的Boost库的知识，所以理解起来不是很容易。首先，串口程序实现了双向的异步读和写的功能，这用到了Boost库中的serial_port以及thread的内容。程序初始化时载入相关的串口参数，比如说波特率、校验位等。之后，程序中订阅了两个串口的Topic，用来获得数据。同时还定义了一个Topic用来发布数据到ROS的节点管理器中。最后代码中启动了主线程，而它又在自己的代码块中调用了主运行函数，接着程序会开始一次异步读操作，读取数据并进行处理。异步写的操作则是只有在接收到Topic的请求后通过回调来实现的。<br>

**问题：**<br>
1、代码中的bind用法不是非常理解，只是大概知道它能绑定函数指针和成员函数。还有另一个Boost库中的用法是function，这个东西实在是很难在短时间内理解明白。我发现它在代码中的功能主要是用于回调函数，但具体的实现机制还不清楚，需要之后仔细研究。<br>

**计划：**<br>
1、马上把xm_robothw的代码看懂并按照机械臂的要求进行修改。<br>
2、理解电子组事先定义好的串口协议，重点是发给电机的数据长度以及数据的内容。<br>

---
## 2015.6.9-6.13

**完成：**<br>
1、这几天我主要是好好研究了一下xm_robothw中的内容，总体感觉收获还是很多的。xm_robothw是上位机与下位机之间最重要的桥梁。其中主要涉及了Joint的Controller、Hardware、Limits和Transmission等Interfaces。当然整个代码中还含有与xm_serialnode包通信的Topic。<br>
(1)、xm_robothw文件中定义了机械臂的两个主要Topic：RecvData/3和RecvData/4。通过节点的订阅和发布，实现数据流的移动。<br>
(2)、Joint的hardware_interface里有有Effort、Velocity、Position等类型。xmbot代码中机械臂用的是位置控制类型，所以只要按照串口中定义好的协议给机械臂发送位置数据，就可以控制机械臂的位置。<br>
(3)、Joint的limits_interface可以直接从URDF文件或者.yaml的配置文件中读取所需的关节参数，并载入到参数服务器中。不过现在的时间还是比较紧张，这一部分我并没有特别仔细地学习，之后需要尽快加上。<br>
(4)、Joint的Transmission的那部分，原理是将关节与电机的数据进行转换，这是整个文件中最重要的组件之一。有了它以后，就可以让机器人自己通过程序间的接口来接收关节数据，并自动地把其转换成执行器即电机的位置数据。同时也可以从嵌入式硬件中读取电机的数据，并转换成Controller需要的数据类型，实现双向的数据流通。<br>

**问题：**<br>
1、launch文件中载入了底盘的Controller配置文件到参数服务器中，并且在之后的步骤中，将其导入的Controller Manager中。那机械臂的配置文件如何写呢？机械臂的Controller有joint_names，它的yaml文件的格式可能会与底盘的不同。<br>
2、机械臂RobotHW中的transmission_interface自己是按照ros_control官方Wiki改的，可是在代码中一加上Transmission的那部分，运行程序时就会有莫名的"Process died"的问题，而且并不会有串口数据产生。我和壕查了各种网上的资料文档，但还是没能解决这个问题，看来之后还需请教学长了。<br>
3、之前自己给串口发Topic，串口的双向指示灯都没有亮起。之后在电子组的帮助下，发现原来机械臂各个关节的模块编号是重新定义过的。用了新的协议之后，串口终于有了数据。根据串口程序里的定义，串口是订阅/SendSerialData的这个Topic来获取由xm_robothw发送的关节位置控制数据的。但我用rqt来修改/SendSerialData里的数据值并发布这个Topic时，机械臂并没有按照我的意愿来动，这个很奇怪，我觉得没有什么其他的大问题，最后推测最有可能出现问题的地方就是数据的发送格式不对，这个还要自己尽快研究一下。<br>
4、xm_robothw中的机械臂与底盘的代码同时取消注释并运行时，会有冲突发生。但问题貌似不在串口程序，因为控制底盘与机械臂的STM32控制板是两个，所以是互不影响的，把代码分开就应该不会有什么太大的问题。<br>

**计划：**<br>
1、将xm_robothw中的机械臂与底盘代码进行分离，这样以后调试会容易很多。<br>
2、尽快把Joint的Limits加上，让机器人的机械臂可以自动获得关节的限制，为之后的避障做准备。<br>
3、仔细研究下Joint的Transmission部分，狗哥说问题2中的问题是程序的Transmission并没有运行。解决的方法是自己看官方Transmission的源代码，然后自己重新写一个适合xmbot机械臂的Transmission。<br>
4、如果有时间的话，尽可能地抽出时间继续学习roscon 2014中的ros_control的文档。<br>

---
## 2015.6.14

**完成：**<br>
1、今天是考试复习周开始之前的最后一天，我搞定了机械臂的键盘遥控控制。遥控机械臂的代码主要是来自于ROS官网上的TurtleBot机器人，代码中为了控制多个机械臂的正反转，我多定义了几个键盘响应的地址。因为代码中已经搞定了键盘中断的问题，所以我只需要在switch-case分支中增加或减小关节变量的值，在每一次循环的最后把数据通过Topic发送出去就行。而xm_robothw中则订阅该节点的数据，并把参数传递给Pub_arm_cmd函数，最后由串口发送关节位置到电机，控制电机的移动。我测试了一下，发送函数Pub_arm_cmd没有任何问题，可以用键盘来遥控六个关节的角度变化，从而改变机械臂的位置。总体的效果还可以，就是有的时候机械臂会突然出现快速地位置变化，感觉很惊险。<br>

**问题：**<br>
1、xm_robothw中有关Topic回调函数里的数据使用方式不是很清楚，具体就是Boost里的智能指针引用规则。<br>

**计划：**<br>
1、考完试之后，首先尽快把Joint的Limits和Transmission加入到机械臂的RobotHW代码中。<br>
2、做完并测试整个机械臂的底层封装，确保没有任何问题。<br>
3、学习roscon 2014的ros_control的文档。<br>
4、修改遥控机械臂的代码，增加关节限制以及优化操作界面。<br>

---
## 2015.7.7-7.12

**完成：**<br>
1、修改芳姐的xm_TLD代码。尽管CMakelists.txt和package.xml中的内容已经经过了适当的修改，但我自己在编译测试时，发现源码中还是会报很多的错。后来自己分析了一下，发现芳姐在改xm_TLD包名字的时候，并没有更改所有与名字有关的.h和.cpp文件。在进行了更正之后，编译可以顺利通过。<br>
2、给xm_robothw中添加关节限制的部分，但是出现一些问题，以后再修改。它的过程首先是让xm_robothw中读入URDF文件中有关关节Limits的信息，并在每次在write的时候把Limits强制加到之前注册的关节句柄中去。<br>
3、添加了xm_teleop包来遥控机械臂。相比之前我所完成的内容，我添加了每个关节的限制，并且对操作界面做了一定的优化。<br>
4、我学习完了roscon 2014的ros_control的pdf文档资料，最大的收获就是自己对整个ros_control的架构有了更深入一步的理解。其中它讲述了ros_control的数据流循环。它的流程是Read from HW -> Actuator to joint state -> Controller manager update(emergency stop handing) -> Joint limits ecforcing -> Joint to actuator command -> Write commands to HW。这个与我之前自己学习ros_control所理解的差不多，不过有所不同的是control_thread是可以和其他spinner_thread进行通信的。此外还有Controller Manager中对相应Controllers的lifecycle管理。它的整个过程也是一个小型的循环，首先是load由初始态到达stop的状态，接着start从stop态进入running的状态，触发stop命令可以从running态进入stop状态，最后执行unload命令能让Controller从stop态转变成初始态。<br>
5、这周的最后一天，我直接上有关Transmission部分的源码，仔细看过之后，我基本明白了Transmission的实现原理。源码中的Transmission定义了关节转换的公式，其中包括simple_transmission和differential_transmission。我记得自己之前在给xmbot添加Transmission时，代码总是在运行时出现无故的进程死掉问题。当时我是按照官方的Wiki文档改写的，现在我觉得问题的原因很有可能是程序push back电机或关节初始变量值时，因为其初始值并没有在之前的代码块中载入或初始化，所以在运行程序时，hardware_interface会因无法转换数据而报"Process died"。<br>

**问题：**<br>
1、根据电子组告诉给我的信息，串口发送的数据是电机的旋转角度，而不是我之前认为的关节的角度。所以我之前完成的遥控机械臂的程序是有问题的，它控制的并不是真正的关节的位置，而是电机的位置。这个我会在添加完Transmission后再更改。<br>
2、我现在对于Transmission的问题主要集中在为什么Transmission只是在RobotHW中初始化一次，而不是每次在程序的执行循环中运行一次（可能我没有仔细看清楚？）。还有就是假设我让一个机械臂的关节位置发生变化，那为了其他关节能保持相对的角度不变，就需要在一个执行周期中，每个关节都需要改变位置，这其中就涉及相当不简单的计算问题。<br>

**计划：**<br>
1、给xm_robothw加上相应的transmission_interface后把之前的遥控机械臂的代码再进行修改，使其可以真正地控制机械臂的运动，力求做到一定的精确度。<br>
2、自己编写Transmission的部分，使电机和关节数据可以轻松地相互转化。<br>

---
## 2015.7.13-7.23

**完成：**<br>
1、RoboCup2015比赛准备与调试，之后我会把总结写出来。<br>

**计划：**<br>
1、继续调整机械臂的位置精度。<br>
2、看ros_control中有关joint_trajectory_control的源码。<br>
3、理解关节轨迹中的时间戳问题。还有就是听学长说轨迹貌似是二次的曲线，需要Tracking这条曲线，现在听起来还是没有搞懂，不过我相信这个只要多花些时间看源代码就可以解决。<br>
4、看《Robotics Modeling Planning and Control》书。<br>
5、在rviz中可视化关节在Planning Scene中的轨迹效果。<br>
6、给xmbot的MoveIt!组件中添加OctoMap，让机械臂在Planning Scene中有障碍物的时候可以实现精确的关节运动轨迹。<br>
7、学习物体识别与机械臂之间的接口。<br>

---
## 2015.7.24-8.1

**完成：**
1、我已经把之前没有编译过的Transmission部分搞定了。现在每一个关节和电机的位置转换应该比较准确了（至少在上位机层面上），不过最后的效果还需测试才能知道。机械臂运动过程中还存在大臂移动，小臂和手腕位置如何补偿、小臂移动，手腕位置如何补偿，这两个相当棘手的解算问题。这个我也已经写了部分代码，实际的运行情况还得我回学校之后再行测试才知道。<br>
2、我看了《Robotics Modeling Planning and Control》中Trajectory Planning那一章里重要的概念性论述，感觉这本书确实写得非常专业，用词很严谨，理论性很强。我从看的有限篇幅中理解到的内容主要是trajectory是在路径的基础上添加了时间的约束，即时间戳。具体的公式中有用到计算方法中的样条插值和多次插值，这样计算的目的是使整个轨迹可以更平滑。当然，我觉得理论强的书不是看一遍就能搞明白的，而是多次阅读并结合实际操作才会有好的效果，而且现在的时间也不是很充分，为了十月的比赛项目，我们先得把整个大概的框架搭起来，至于更高端的算法等之后再说。<br>
3、看了joint_trajectory_control的Wiki介绍，理解了一些东西。<br>
4、自己继续完善了xm_robothw的代码，现在终于可以把输入的关节位置转换成电机的数据，算是有了一点进步。不过，这也就是单个关节，而多个关节的解算还存在一些小问题。而且对于之前关节的限制问题，我还是要看一下源码，好好研究一下。现在自己对关节限制的那部分代码的原理还不是很清楚，并不知道自己之前写的是否可以发挥作用。总之，硬件层封装没有想象中的简单。<br>

**问题：**<br>
1、自己已经根据官方的Wiki文档进行了适当的改写，但代码在进行编译的时候会报很多的错误。其中的一类错误是vector类型的数据没有办法被赋值，错误具体是"Cannot convert 'float*' to 'double'"或者是"Cannot convert 'double*' to 'double'"。这个令我非常费解，到底是什么导致了这种问题？我初步认为问题发生可能是没有合法的使用vector的下标引用所造成的。还有就是在运行xm_robothw节点时，程序会自动地抛出异常，具体是"Transmission reduction ratio cannot be zero"，我推测是需要把默认的reduction值显式地初始化出来才行。<br>

**解决：**<br>
1、上面的编译问题已经得到了解决，主要错误是出在了我没有看清楚等式两边的元素类型，一个是值，而另一个是指针，这样赋值是肯定不会编译通过的，算是自己犯了个非常低级的失误吧。不过就算是编译完成之后，在运行时依旧会有程序直接死掉的问题，这个异常的问题其实在终端里有抛出异常，我之前并没有太注意，没有仔细看终端里返回的问题原因，这个只能怪自己不认真了。问题具体是：
(1)、simple_transmission中的reduction不能是0。因为公式里有reduction作为分母的情况，所以不可以是0。
(2)、numActuators()或者numJoints()返回值必须是1。这个之前自己就有疑问，就是这个公式每一次到底可以转换多少关节或电机的数据呢？后来由于这个错误的出现，结果算是得到了验证。那就是一个公式只能转换一个，所以ActuatorData和JointData类型的结构体应该是5个，前四个关节利用前四个结构体存取自己的位置信息，而最后两个差速关节用一个结构体保存数据便可。<br>

**计划：**<br>
1、继续修改xm_robothw的代码，这次一定要保证测试没有问题才行！。<br>
2、继续看joint_trajectory_control的代码。<br>
3、学习《ROS By Example 2》中有关状态机的那部分。<br>

---
## 2015.8.2-8.9

**完成：**<br>
1、差速关节的解算应该没有什么问题了。我是把原本两个自由度进行了分解，这样我就可以读取和保存俯仰和旋转两个维度的关节位置数据而不用像之前那样担心二者之间会相互影响了。之后只要再根据不同的情况对关节数据进行转换，并把二者的电机数据进行一定程度的拟合，就能确保最终的数据是我们想要的。<br>
2、已完成多关节的运动解算，但细节方面还需要一些时间进行调试。总之，基本的功能算是搞定，以后再改。<br>

**问题：**<br>
1、现在有一个关于机械臂手腕差速控制的问题。因为所有的电机都是用位置进行控制的，所以我之前对差速手腕的理解其实是有一定的偏差。我在上位机控制的是关节而不是电机，所以在编写程序时就自然需要对于两个电机进行转换，把其变成关节的俯仰与旋转角。但问题就存在这里，因为两个电机是同时作用在两个关节中的每一个自由度，也就是说前一个自由度的电机位置是会对之后自由度的控制有影响，即它并不是独立的。我比如说先让每个关节加相同的位置，那手腕就会升起或者落下，这时我再让两个电机向相反的方向移动，那手腕便会自旋，可旋转之后的两个电机数据就不像之前的那样同步了。这样之前设计的手腕关节限制就会作废。我认为出现这种现象的原因是由机械零位以及特殊的差速结构共同造成的。<br>

**解决：**<br>
1、我的解决方案是暂时先不考虑关节限制的问题，这样差速关节我们只需关注是否两个电机同步地做出相加、相减、以及一加一减的行为就可以了。这主要是出于处理方便的考虑，毕竟这是我们第一次要真正地在实地比赛中完成机械臂的抓取测试。尽管我一定会拼尽全力把机械臂做好，但现在积累的经验毕竟还是少，所以为了整个动作的执行，暂时牺牲一定的精度也是可以接受的。后来，我仔细思考了一下，发现可以先将两个关节的自由度独立开来，就像高中物理中所学的力的分解那样，也就是先分别独立地计算各关节的角度，然后再根据情况把两个自由度的数据进行整合，这样得到的最终合数据应该与实际的相差不多。<br>

**计划：**<br>
1、还是要尽快解决多关节解算的数据不稳定的情况。<br>
2、快速入门SMACH，把基本的教程都要仔细学习一下。<br>
3、再复习一下有关Action那方面的知识。<br>
4、根据前两个计划中所用到的知识去重点地理解关节轨迹的实现。<br>

---
## 2015.8.10-8.17

**完成：**<br>
1、调查了基本的语音合成和语音识别的解决方案。语音合成的有Festival、Espeak、Ekho，当然还有中科大的科大讯飞，而语音识别的目前只有CMU的Pocketsphinx。《ROS By Example 1》中的语音识别和发音的教程已经测试完，我发现精度并不像之前想的那样高。不过还有《Learning Robotics by Python》那本书，其中也有一定的有关语音识别的部分，可以稍微研究一下。<br>
2、团队的标志、海报和队服已经完成基本的资料收集。打算再精细一下，把它发给高中同学，让他帮我们设计这些东西。<br>
3、把MoveIt!中的Interactive Marker配置出来了。不过我在用Interactive Marker去移动整个机械臂时，它只能移动到一定的位置。这个之后还是要调整一下。<br>
4、把MoveIt!中的OctoMap调了出来，之前没出现是因为配置文件中的frameName没有设置成自己机器人的。不过虽然在Gazebo中可以读到深度点云的数据并在Planning Scene生成OctoMap，但OctoMap并没有实时更新，也就是说我移动物体OctoMap并不会有变化，很奇怪。<br>

**问题：**<br>
1、我之前在xm_robothw中用到的Controller是joint_position_controller，可是它没有实现MoveIt!中的关节控制Action。所以在开始用move_group进行关节轨迹规划时会出现错误，没办法继续下去。<br>
2、我按照书上的教程用Arbotix配置了机械臂，但在rviz中进行可视化时，会有部分关节的tf转换不对，这会使得机器人的有些关节发生错位。<br>

**解决：**<br>
1、《ROS By Example 2》那本书中有讲过arbotix_python的用法，它被设计是用来控制舵机机械臂的，而且它在内部实现了关节轨迹的接口。其实它的Controller不是真正的Controller，而是直接fake出来的。不过我想了一下，我们的机械臂虽然是靠直流电机驱动的，但关节的运动行为还是和舵机搭建的差不多，所以我可以在软件层先尝试地应用这个包，让它能与MoveIt!进行通信交流，这样move_group会把关节计算的结果再返回给Arbotix，Arbotix再将结果重新发布到/joint_states上，之后的处理就很简单了。订阅/joint_states数据并把它直接发给我之前在xm_robothw中定义好的主题/joint_pos_cmd上。完成此步后，机械臂应该就可以按照我的想法移动了。尽管它还不是非常智能，但我希望能以最快的速度先实现一个机械臂的抓取流程，测试一下，不行再更换别的方案。<br>

**计划：**<br>
1、新写个joint_states的订阅与重新发布的节点，让它能给xm_robothw发关节数据。<br>
2、根据实际测试关节轨迹的结果来改进关节转换解算公式。<br>
3、理解行为树的基本用法，特别是如何把它和机械臂的接口连在一起。<br>

---
## 2015.8.18-8.25

**完成：**<br>
1、搞定在一个文件中进行数据的订阅与重新发布。把joint_states和joint_pos_cmd连在了一起，使得关节数据能从上位机发到下位机。<br>
2、我把之前定义的/joint_pos_cmd主题进行了分解，给每一个机械臂关节都定义了一个Topic，这样发送与接收关节数据就可以并行，不会出现以前数据会有丢失的情况。<br>
3、解决关节转换电机数据后时常会有归零的严重问题。<br>
4、解决Topic不能给所有电机都发送电机数据的问题。<br>
5、完成了小臂的多关节解算，测试后效果非常好。<br>

**问题：**<br>
1、我在编写数据订阅与发布的节点时遇到了问题，因为是在同一个C++文件中进行编写，而且Publisher是要每次在Subscriber的Callback函数中执行。所以为了让程序能编译过，我会用两个不同的ros::Nodehandle。句柄不一样看似是没有任何问题，但在执行时，发布的Topic根本就不存在，我想这是因为Master在管理节点Topic时会根据不同的句柄进行不同的处理。简单来说就是这两个Topic没有处在同一个空间中，当然也就不存在数据间的连接与共享。<br>
2、关节转换电机数据后总会不定时地出现归零的严重问题。<br>
3、串口Topic总是只发送两个关节的数据，而其他的并没有任何反应。<br>
4、当我订阅多个关节的数据并重新发布出去时，发现只有最后的数据才可以真正地发送出去。<br>

**解决：**<br>
1、在经历了各种网上搜索之后，我找到了一个最简单的解决办法。就是直接定义一个全局的ros::Publisher类型的变量，在main()函数中统一使用一样的ros::Nodehandle来创建Publisher和Subscriber，然后把结果赋值给那个全局的Publisher，最后再让这个变量去回调函数中去发布数据就没有问题了。<br>
2、在经过我的调试后，我终于发现问题的根源是数据在取地址之后在对指针引用时会出现数据的丢失，即数据值会突变成零。我的解决办法是直接用vector类型的数组直接保存元素值，最后测试的结果很理想。看来自己还是需要多学习。<br>
3、在经过简单订阅Topic数据测试后发现，问题的本质是由于不同的数据接近同时地发送到同一个Topic上。也就是说所有关节的数据会在一个执行周期内全部发送出去，那么有的电机就会收不到数据。我的解决方法有两个，其中一个是每次选择一个数据发送并让程序执行一个周期，另一个办法是直接在函数内部定义一个延迟，让相邻两次发送函数间隔一个执行周期。<br>
4、解决办法是把处理并重新发布的整个函数写到回调函数中去，这样在一个进程执行期内，数据不会丢失。<br>

**计划：**<br>
1、尽快把手腕差速电机的多关节解算完成好，让大臂、小臂和手腕可以一起进行精准的关节位置解算。<br>
2、开始根据比赛的流程写不同过程的Action，要确定准确的关节位置。<br>
3、继续学习MoveIt!方面的知识，有机会的话可以在比赛中用到。<br>

---
## 2015.8.26-8.31

**完成：**<br>
1、这次在忧神的帮助下，我重新把机械臂的公式加入到代码中去。经过测试，机械臂终于可以按照我们的想法去运动了。这里面包括升降、腰部、大臂、小臂以及手腕等关节的位置解算。其中升降、腰部、大臂是主动，小臂可以做到主动和从动补偿，而手腕部分目前可以做到俯仰自由度主动和从动补偿，但这次比赛我们计划只让手腕做到从动补偿就够了。<br>
2、完成物体抓取的行为树Action接口编写。对于机械臂，我们的策略是让机械臂根据物体识别所返回的空间位置信息来做出相应的轨迹，这个轨迹目前是基于z轴，即高度的改变。对于x和y轴的运动则是由底盘移动来完成。<br>
3、配置好了基础的MoveIt!，在简单轨迹方案测试过后可以尝试加入到机器人中去。<br>

**问题：**<br>
1、自己在给机械臂加入gripper_action_controller时，总会有"Could not find name on param server"的错误，我在Google上查了很多资料，但有用的很少，其中一个解决的办法是将gripper_action_controller注册到hardware_interface::RobotHW类中去，但问题还是没有得到解决。<br>
2、我之前给机器人加的是Arbotix的Controller。在MoveIt!里做运动轨迹时，从joint_states里可以看到每个关节都有数值的连续变化，而当我想用position_controllers/JointTrajectoryController时，基本的配置是没有什么问题的。但是我在用MoveIt!的API来控制关节的轨迹时，发现关节跑的是路径而不是戳上时间戳的连续轨迹变化，感觉这是个比较麻烦的问题。<br>

**解决：**<br>
1、目前网上的各种方法均已尝试过，依然没有把gripper_action_controller配置起来，所以我的思路是先把这个东西放下来。因为机械手爪并不算机械臂的自由度，所以在做Motion Planning时并不会受到相应的影响。总之，这个手爪在实际机器人跑起来时，可以单独地控制，而加Controller无非是想把硬件层封装的更好，使得上位机节点能更方便地调用。这个问题我会之后继续来研究，目前情况的重点是先将整个机器臂的框架搭建起来，至于小的问题也是可以暂时忽略掉的。<br>
2、狗哥跟我讲了他的解决办法。其中的主要内容是MoveIt!在解算轨迹时，会在沿路设置很多的路点，当其检测到两个路点之间没有碰撞或其他的约束时，它会寻找近路，即取消两点之间的路点。虽然这会使得轨迹能以更快的方式到达目标点，但也可能会造成MoveIt!在规划时因为条件的理想化而取消起点与终点之间的所有路点，最终导致关节运动会以路径方式完成的。这样的运动方式很快并且不稳定，因此在实际机器人的抓取过程中这种情况是绝对不允许出现的。解决的办法是看moveit_core中的有关时间参数化插值的代码，理解大概的含义，重点观察轨迹运动过程中是否有轨迹时间插值的插件被载入并且在运行中，如果没有则需要自己根据官方的代码来实现。<br>

**计划：**<br>
1、加快测试物体抓取测试时的行为树接口。<br>
2、尽快搞定底盘与机械臂联调时的串口问题。<br>
3、可以尝试使用MoveIt!来配置机器人轨迹。<br>

**总结：**<br>
1、MoveIt!中包含了控制机器人运动的各种核心功能。其中对URDF文件的解析可以生成机器人运动学的求解方法，而对于运动学中比较难的逆运动学方面用的是开源的KDL库，这个库的实现是基于数值计算方法的。对于轨迹规划方面，MoveIt!是使用了第三方的解法库OMPL来实现的，这个库是基于随机化算法的。同时MoveIt!还提供了一个时间参数化的控制点插值，将轨迹分为很多路点，以方便控制器控制关节的运动轨迹。<br>
2、控制器是闭环控制的主要组成部分。它需要接收MoveIt!的位置指令，并驱动每个关节的电机运动。控制器在整个机器人的控制中要实现的功能主要有：传感器、执行器的驱动、位置插值、闭环控制（PID）等。最后大概总结一下整个机器人运动系统的搭建的过程：<br>
（1）、建立机器人的运动学与动力学模型。<br>
（2）、配置机器人的MoveIt!。<br>
（3）、编写机器人的控制器（包括设备驱动）。<br>
（4）、整合各种模块，完成机器人系统的集合。<br>

---
## 2015.9.15-9.20

**完成：**<br>
1、看完dynamixel_motor和arbotix_python的所有源码，重点是看了舵机串口通信的协议以及与实现的功能，理解其工作的机制与原理。<br>
2、完成手爪舵机旋转角度与夹持器之间距离的位置转换，经过实际的测试可以让机械手爪做到很精确的物体抓取。<br>
3、完成机械臂抓取高度的程序的编写。<br>

**问题：**<br>
1、之前自己根据《ROS By Example 1》中教程配置过的Dynamixel舵机可以通过arbotix_terminal软件读出ID、温度等很多重要信息。但是这次不知出现了什么问题，换了很多同类型的或者是其他型号的Dynamixel舵机，都不能从串口中读到舵机的信息。而最令人感到困惑的是我在Windows上是可以用Robotics公司开发的RoboPlus软件连接到相应种类的舵机，而且读取到的舵机号、位置、波特率的参数配置都是没有任何问题的。之后我又仔细检测了整个舵机的供电以及USB2Dynamixel适配器的连线情况，也是没有问题的。我大致认为问题可能出现在ROS的arbotix_python包中，即读取软件arbotix_terminal的参数配置上，不过其后我又在其他两台电脑上配置，还是不幸地出现了无法读取舵机ID的问题。<br>

**解决：**<br>
1、先努力在Google上收集问题的解决办法，如果在短时间内还是无法解决问题的话，就更换Plan B。Plan B的内容是直接用单片机Arduino控制舵机，先让ROS通过串口与Arduino通信，发送舵机应该运动到的位置，之后在Arduino层调用别人已经封装好的Dynamixel库来控制舵机。与此同时从舵机中读取到力矩、温度、位置等信息，把其返回给上位机，主要是做到闭环控制与安全检测。<br>
2、狗哥给的建议是直接用dynamixel_controller去ping相应的舵机，后来我阅读官方控制Dynamixel舵机的源码，自己编写测试程序来ping舵机，但最终的结果还是没能让电脑与舵机取得连接。很多的办法都想过了，问题依旧没有得到解决，就在百愁莫展之时，出人意料的事发生了————舵机竟可以与电脑连接在一起，并且可以控制了！代码没有改过，电气连线没有改过，很大的可能是因为我在控制时又重新把控制开关调了一下，不管原因是什么，最后的结果还是不错的，希望下次不要再在这种低级的问题上浪费太多的时间与精力。<br>

**计划：**<br>
1、尽快测试机械臂在进行抓取测试时其高度能否精准达到可以抓到物体的程度。<br>
2、规划机械臂初始位置以及整个抓取流程的动作设定，力求做到稳定。<br>

---
## 2015.9.21-9.26

**完成：**<br>
1、完成xmbot的joint_states节点的编写。它可以从类型为/xm_arm_controller/state的Topic中订阅相应的关节数据并把它重新发布到/joint_states上，这样robot_state_publisher就可以直接订阅/joint_states数据从而在rviz中可视化出整个机器人关节变化时机械臂的运动状态。<br>
2、完成xmbot的机械臂高度测试，实际精度很不错，与直接用卷尺测得的高度差不了太多。<br>
3、完成xmbot的手爪抓取测试，抓取物品时力度可以，不会出现过载的问题。<br>
4、完成xmbot的机械臂与底盘串口联调，数据发送的会有些延迟，还需改进。<br>

**问题：**<br>
1、在研究发送关节数据到/joint_states时，我发现如果用官方包中的joint_state_publisher是没办法直接通过程序内的Topic发布器控制关节在rviz中的变化。原因是自己写的程序和joint_state_publisher都需要将数据发布到/joint_states上才能被robot_state_publisher接收，而当其中一个程序发布关节数据时，另一个与其发生冲突，最后的合数据并不是单一稳定的而是在两个值之间按频率快速地跳变，这样导致的结果就是机械臂在rviz内无法移动。<br>
2、在编写可以发布/joint_states类型的节点时，发现如果不给/joint_states持续地发布位置等数据时，在rviz中关节的坐标转换便会发生严重的错误，导致此种问题的原因是robot_state_publisher必须连续地订阅/joint_states的数据才能不断维持正确的关节位置转换。<br>
3、在xm_robothw程序中发现问题。在大臂位置改变时，小臂为保持与地面的水平需要进行从动补偿。而当大臂回归到零点时，小臂的补偿值没有相应的归零，而是向相反的方向偏移的更多，最后导致小臂完全跑飞，非常危险，因此这个问题需要火速解决。<br>
3、在启动xm_arm_action_get_position节点时发现串口程序的双向数据发送变成了只能向下位机发送的状态，而且关掉程序之后，串口程序怎么重启都不能恢复，只有重新启动下位机控制板才能恢复正常。这个问题我在之前写过一个类似的程序时并没有出现，所以要仔细研究问题出现在哪里。<br>

**解决：**<br>
1、自己看了arbotix_python包中有关的源码，并且借鉴了《ROS By Example 2》中的部分内容，发现比较好的解决方案是直接自己写节点发布同名同类型的/joint_state主题，并且在发布的同时让程序订阅/xm_arm_controller/state。这样就保证了/joint_state上始终有数据发布，机器人在rviz中便可以正确地运动。<br>
2、xm_robothw中的问题已经修复。问题出在关节的最终角度位置为补偿值、主动值与上一状态的和，而出错程序在第一次计算时是没有问题的，因为jnt_forearm.position[0]在每次获得新值时代表关节的主动角，而完成计算后它的值变为最终的合位置。所以在下一次循环，由于没有进行相关的处理，加的值会出现问题。解决的方法不是很难，是直接用上一次的补偿角加从动的变化值最为当前总的合位置，这样程序就在下一次循环中处理得到正确的值。<br>
3、之前数据丢失的问题，我的解决办法是每次只发布一个关节的数据，等这个关节的位置到达实际的目标后，再给下一个关节发数据。以此类推，虽然无法做到每个关节同时的运动，但最终的效果也还可以接受。<br>

**计划：**<br>
1、重点搞定一次只能给/joint_pos_cmd发送一个关节数据问题。<br>
2、重新理清思路，把全关节解算搞定。<br>
3、测试写的所有有关机械臂的Action代码。<br>

---
## 2015.9.27-9.30

**完成：**<br>
1、完成xmbot机械手腕Action程序的编写，可以实现手腕提起与落下。<br>
2、完成xmbot机械臂手腕测试程序的编写。<br>
3、搞定xm_robohw中有关机械臂和底盘串口数据转换的问题。<br>

**计划：**<br>
1、尽快测试通自己写的整个Plan B的机械臂抓取测试方案。<br>
2、做到全关节的解算，为之后的研究做准备。<br>

---
## 2015.10.1-10.5

**完成：**<br>
1、搞定机械臂在进行初始化运动和抓取预备动作时的关节数据发送问题，可以让每一个关节以一定的发送顺序把相应的角度信息发送给下位机。<br>
2、修改xm_robothw中差速手腕关节到电机数据的转换系数，使机械臂的手腕关节能以更精准的角度到达目标位置。<br>
3、重新定义了多关节运动的Topic，使程序经过一定的延时可以让每个关节都在一定的时间范围内做到同步的移动。<br>
4、修改手腕Action控制程序，使其可以匹配新的关节位置Topic。<br>
5、修改xm_arm_height_action_server程序，在其中的数据接口中添加物体与机械臂零点的垂直距离。<br>
6、写完机械臂全关节解算方法，需要实际测试验证。<br>

**问题：**<br>
1、自己在编写让机械臂可以移动到初始位置的代码时，遇到了一些问题。由于目前xm_robohw在接收关节数据方面很有限，一次只能获得一个关节的数据，那么在机械臂数据发送方面就需要考虑关节发送数据的顺序。而在joint_position_controller的Action中所有的关节数据是同时进行计算的，所以问题来了，如何做到数据按序输出而又能保证数据的完整性呢？<br>
2、虽然在机械臂抓取测试中没有发现关节延迟的问题，但耀在和我测试抓取测试的总状态机时，发现机械臂在初始化位置时会有一定的延迟。这里的延迟指的是当状态机已经得到Action Sever所返回的数据时，机械臂依旧没有到达目标位置。这个问题的原因是由于之前在发送关节数据给串口时为了使串口不崩掉而每次只发送一个关节数据，但这样会导致如果用follow_joint_trajectory的Action作为关节解算的桥梁的话，那只有第一个位置发生变化的关节可以进行位置的更新，而其它的只能使用自己写的函数来实现关节角的连续移动。如果真是这样，那在第一个关节做完计算后Action就肯定会结束并返回相应的值，而实际上机械臂只是移动了一个关节左右。<br>
3、在根据问题2修改了关节位置发送Topic时，发现在上位机上测试时没有问题，而实际与机器人的串口连接时，发现数据会像之前那样使串口崩掉。<br>

**解决：**<br>
1、我的解决方法是先让ROS中默认的joint_position_controller去控制大臂，而大臂在运动时，根据Plan B，小臂会时刻与地面保持水平，这样一来控制大臂就相当于在下位机层面同时控制大臂和小臂电机。当大臂完成最终运动后，接着需要运动的关节是升降，而升降关节比较特殊，它的移动速度是固定的，直接发给它一个位置就可以让其上升或下降。升降运动完之后是腰部和手腕关节，因为所有关节数据在joint_position_controller对大臂规划完之后就不再改变，这样想让其他关节能依旧运动到Controller所指定的位置，就必须先用变量把位置保存下来，然后自己编写可以使关节能连续转到目标位置的函数，而最重要的一点是你需要保证对于大臂不动这种情况时，腰部能直接接受Controller的解算数据。同理，对于手腕也是一样的。那么总结一下最后的方法：对于大臂和升降是不用管的，而腰部和手腕部分是需要按照情况分别进行讨论的。在代码中，只要大臂或升降运动过的话，那之后腰部和手腕的运动是调用用户自己写的转换函数；而腰部和手腕不动，动了腰部的话，腰部用系统自带的程序发送数据，手腕使用用户自己写的。同理，若只动手腕，那就直接让手腕调用系统的Controller去发送数据。总之，把程序中的逻辑理清楚，就不会有太大的问题。<br>
2、对于问题2的解决方法有几种。最好的方法是用一个数组直接一次性保存所有关节角的信息，这样在传递数据给xm_robohw时就不会出现因一次发送多个关节数据而使得串口死掉的问题，而且实时性也可以得到保证。<br>
3、问题的原因是我在一个回调函数周期内一次性地处理了六个关节的数据，串口发送函数至少到目前为止还不可以接收如此大量的数据流。解决办法是在每一次循环中加上一定的延时处理，使得数据可以顺利地发给下位机，至于延时时间的多少，这个可以从实际测试中获得。<br>

**计划：**<br>
1、重写xm_robohw中有关机械臂机械臂解算的函数，使机械臂最后能具有完整全关节运动的能力。<br>
2、希望自己能把有关机械臂解算的部分独立成一个ROS包，方便以后其它程序的调用。<br>
3、学习ROS官网上有关Plugin的部分。自己尝试写个机械臂的Plugin，用插值算法使其运动的轨迹能比较平滑。<br>
4、继续配置机械臂的MoveIt!。最后理想达到的效果是若在rviz中指定某个位置点，它可以通过动作规划算法逆解出每个关节的旋转角度从而到达那个位置。<br>

---
## 2015.10.6-10.9

**完成：**<br>
1、经过多次测试，新写的全关节解算程序至少目前没有出现数据上的问题。<br>
2、完成rviz中机械臂的控制，可以实现关节任意角度的遥控，并验证了自己写的joint_states没有问题，为之后的MoveIt!配置做好基础。<br>

**问题：**<br>
1、这几天在调试机械臂时发现，机械臂在进行移动时速度会经常性地发生变化而且伴随有运动的延迟问题。也就是说机械臂在以正常速度运行时，Action服务器刚好可以在机械臂到达指定位置时返回成功的结果。而我们发现在机械臂移动速度变快时，底盘都开始移动了，机械臂还没有到达目标位置点。而且有时延迟问题非常严重，直接或间接地干扰到了之后的整个抓取流程。<br>
2、每次状态机在执行打开机械手爪的命令时，总是不能在第一次完成，这个问题实在是很令人费解，需要尽快解决。<br>

**解决：**<br>
1、这个问题的原因是因为目前底盘和机械臂不能同时发送数据给串口程序（不过按理来说应该是可以的，但实际测试的结果貌似不行），我们定义了一个串口转换的Topic，而问题就恰恰出现在了这里。因为是Topic，State Machine那方面在发送数据给Topic做模式转换时，会出现发送频率快而使数据延迟到达RobotHW那里的问题，从而导致以上所描述的问题。解决的方法是定义相同类型的Service，这样在State Machine那边只有就收到Service服务器返回成功的标志后，整个State Machine才会继续跳转到下一个状态。经实测，效果果然很好。<br>
2、经过壕神的研究，发现只要将发布手爪的Topic声明语句放到构造函数里初始化就能解决遇到的问题。至于原因，我想是在第一次调用时，程序并没有及时的初始化Topic以及发布相应的数据，而把声明语句放到构造函数就不会出现初始化不及时的问题了。<br>

**计划：**<br>
1、把之前自己写的C++代码做规范化的处理，要在代码的组织上体现面向对象的思想。<br>
2、仔细看一下Hector和Explorer中有关机械臂方面的代码，把程序之间各种关节Topic的关系理清楚，重新调整自己之前写的代码。<br>
3、仔细阅读一下arbotix_python中的有关代码，重点理解程序中是如何实现发布/joint_states数据的。<br>

---
## 2015.10.10-10.13

**完成：**<br>
1、进行了机械臂抓取测试，总体效果基本达到预期。但在抓取的时候还不是很稳定，急需改进。<br>

**问题：**<br>
1、在进行机械臂抓取测试过程中，发现Kinect无法有效地检测贴在机械臂手腕上的二维码。原因可能是机械臂手腕与Kinect之间的角度有一定的偏差。总之，测试的结果不是很稳定。如果有更好的方法，需要尽快更换。<br>
2、也是在抓取测试中，我们发现底盘经常会出现tf转换程序崩掉的问题。这个问题的原因还在探索与研究之中，应该之后就会有解决的办法。<br>

**解决：**<br>
1、Kinect无法检测二维码的问题已经解决，之前用二维码的目的主要是通过测出手爪到Kinect之间的距离算出手爪到物体的距离，但如果手爪距Kinect的距离发生变化，二维码基本就识别不出来了。所以我们改成全部用Kinect的返回值进行相应的计算而得到最后物体相对于机械臂的位置。经过测试，准确度确实得到了比较大的提升。<br>
2、底盘暴走的原因已经找到。主要是因为串口发送数据过多，导致里程计计算出现错误。解决的办法是通过变量赋值，让底盘与机械臂串口发送数据分隔开。<br>

**计划：**<br>
1、希望在比赛前能有时间进行机械臂测试。<br>
2、比赛之后要好好总结机械臂的技术路线，重新思考架构，为之后的机械臂发展做好准备。<br>

---
## 2016.1.22-1.23

**完成：**<br>
1、重新深入地复习了有关ros_control的部分，看了GitHub上其他ROS开发者写的ros_control包。<br>
2、看了最新出版的ROS书《Mastering ROS for Robotics Programming》，其中的URDF、ros_control、MoveIt!、Gazebo部分写得很不错。<br>
3、思考了xmbot新一代机械臂的软件架构，不过有些具体的软件接口等实现问题还要多花些时间来进行验证。<br>

**问题：**<br>
1、在完成xmbot的Gazebo配置后，启动时总会出现"This robot has a joint named which is not in the gazebo model"的问题。<br>

**解决：**<br>
1、根据Google上的解答，得知必须在URDF的link中指定<inertial>才可以让Gazebo使用物理引擎来进行相应的仿真。当然如果URDF中的关节本身就是固定的，那只要不配置Transmission标签就可以了。<br>

**计划：**<br>
1、将所有xmbot组织中有关机械臂的包都重新更改包名前缀，重新实现，这样可以让机械臂包的管理更加方便。<br>
2、先简单地配置一下xmbot的MoveIt!和Gazebo包。<br>

---
## 2016.1.25-1.26

**完成：**<br>
1、配置好xmbot的MoveIt!包，可以通过rviz中的Motion Planning插件控制Gazebo中仿真机械臂的运动。<br>
2、大体上完成整个第二代机械臂的软件架构设计。<br>

**问题：**<br>
1、在完成配置MoveIt!的Controller后，总会在启动MoveIt!中的demo.launch文件是报错。错误的内容是机器人的名字不匹配。<br>
2、搞定问题1之后，在执行Motion Planning时又遇到了新的错误，错误内容是Joint的名字与Controller中定义的不匹配。<br>

**解决：**<br>
1、这是个小问题，其原因是我之前在改写xmbot的描述文件时，把普通的URDF和加有Gazebo标签的URDF文件分开了，并且在分别加载Gazebo和MoveIt!时使用了不同名字的URDF文件。其实机器人的URDF文件可以直接用一个包含Gazebo标签的来表示，这样就把所有需要的参数都包括了，没有必要分开。<br>
2、根据报错的内容其实可以很清楚到底是那部分出现了问题。我查看了move_group输出follow_joint_trajectroy的goal，发现确实只有五个关节数据，而少了joint_lift这一个。解决办法是重新运行moveit_setup_assistant，我发现在机械臂的Planning Groups中的确是添加了正确的Kin.Chain，但在设置机械臂位置时就是没有joint_lift这个关节，之后我在机械臂的Joint参数中添加了joint_lift关节就可以了。我想这个可能与MoveIt!配置Planning Groups有关，在Kin.Chain没有涵盖所需的关节或连杆时，可以通过给Links或Joints中的添加对应的数据来解决。<br>

**计划：**<br>
1、要开始编写机械臂软件底层的接口代码。<br>
2、根据架构画出架构图。<br>

---
## 2016.1.27-1.29

**完成：**<br>
1、机械臂关节状态驱动代码的编写。<br>
2、所有之前xmbot项目的代码已经完整地从GitHub个人账号转移到组织账户中。<br>

**计划：**<br>
1、继续编写机械臂软件底层的剩余代码。<br>
2、完善软件架构图。<br>

---
## 2016.3.27

**完成：**<br>
1、xmbot第一代机械臂的系统与软件架构图。<br>
2、xmbot第三代整个系统和软件的架构图。<br>
3、xmbot第二代机械臂的部分系统与软件架构图。<br>

**问题：**<br>
1、MoveIt!通过Plugin可以与FollowJointTrajectoryAction接口相连接。在用MoveIt!做机械臂的规划时，MoveIt!会作为FollowJointTrajectoryAction的客户端，发布目标的连续多个基于位置、速度、加速度、作用力的轨迹点。而我的困惑是MoveIt!需要订阅/joint_states的数据，那么到底是哪个节点发布这个消息呢？<br>
2、在配置joint_trajectory_controller之后，会在启动时产生七个相关的Topic。其中goal和cancel是客户端（例如move_group）发布，Controller订阅的。status、feedback、result以及/state是Controller发布，move_group订阅的。而command则只由Controller发布。我的问题主要是joint_trajectory_controller输出的Topic是什么？尽管它可以发布state并且能从中获取desired轨迹点集的连续变化的关节数据，但我总觉得我不应该使用它，因为state是joint_trajectory_controller向上返回的Topic，并不是向下发给hardware_interface的，所以我到底在RobotHW中如何使用从MoveIt!发过来的FollowJointTrajectoryAction类型的数据呢？总之，这方面的概念需要仔细地研究一下。<br>

**解决：**<br>
1、我又重新翻了有关ROS的书，看了网上的一些资料，现在终于领悟了/joint_states的含义了。ros_control中有个joint_state_controller，它把从硬件底层机械臂电机编码器返回的位置信息发布到了/joint_states上，以便供move_group以及rviz使用。不过有一个容易弄混的地方是joint_state_publisher也是可以发布/joint_states的，虽然两者的类型以及所能提供的功能是一样的，但我认为后者是适合在没有硬件的情况下使用的。总之，在调试实物机械臂的时候，需要自己把电机返回数据发布到/joint_states上。<br>
2、其实对于这个问题我曾经也思考过，不过那时因为调试时间较短，就换了另外一种方法，没有彻底地解决这个问题。由于这次要使用MoveIt!框架，就没办法了，所以一定要把有关joiint_trajectory_controller相关的概念搞懂才行。<br>

**计划：**<br>
1、将自己已经设计好的xmbot系统与软件架构图草稿画出来。<br>
2、按照设计好的架构图完成xmbot第二代机械臂底层的代码。<br>
3、继续完善xmbot第二代机械臂软件架构图。<br>
4、研究joint_trajectory_controller的实现细节。<br>

---
## 2016.3.30-4.2

**完成：**<br>
1、xmbot整体和机械臂的系统和软件架构图初稿已经完成，有待之后的修改和润色。<br>
2、关节到电机转换程序库已经完成，经过测试没有问题，可以较为精准地转换数据。<br>

**计划：**<br>
1、解决电机到关节转换部分，并且实现程序。<br>
2、看ros_control和ros_controller中有关源码，重点理解RobotHW与Controller的关系与使用方法。<br>
3、按照官方的使用规范编写新的机械臂RobotHW，如果需要则可以自己定制xmbot机械臂的Controller。<br>

---
## 2016.4.3-4.4

**完成：**<br>
1、写完新一代xmbot的机械臂RobotHW程序，还需要对一些细节进行优化。<br>
2、对GitHub上的代码进行了包名大小写的规范化，并修改其他与其相依赖的包。<br>
3、对自己的ROS工作空间进行了适当的规范与整理。<br>

**解决：**<br>
1、我曾经在2016.3.27的开发日志中提到过一些问题，但是经过研究，自己已经搞明白了。其实狗哥在易科上发表过有关ros_control的文章，我的很多问题在狗哥那里已经有答案了，只不过自己当时并没有仔细地看。首先ros_controllers中的很多Controller，比如机械臂用的joint_trajectory_controller等全部是用ros中的Plugin实现的，而且在Controller里面封装了很多好用的控制算法，这样就方便了开发者的使用。当然如果官方的Controller不能满足要求的话，可以自己继承Plugin基类，定制自己的Controller。除了封装算法外，Controller还可以发布或订阅Topic来暴露上层接口。而对于RobotHW，Controller是通过使用相应的hardware_interface来建立关系的。hardware_interface中可以注册变量句柄使其被Controller引用，所有就像狗哥说的那样，ros_control中不存在进程间的通信方式，即不存在消息的传递机制（Topic、Service、Action），只有内存地址的引用。这样只要Controller接收数据并赋值给内存中的已被引用的变量，那其值就可以直接在RobotHW不断循环更新的时候自动被RobotHW程序获取，并通过串口等通信方式向下发送给下位机了。<br>

**计划：**<br>
1、重写之前机械臂的串口程序，以配合我之前刚写的RobotHW。<br>
2、综合调试优化第二代机械臂的底层ROS代码，争取越快越好！<br>

---
## 2016.4.5-4.9

**完成：**<br>
1、完成机械臂串口程序改写并规范化，需要测试。<br>
2、机械臂RobotHW程序中已经添加好关节电机转换函数，经过学弟之前的测试，终于没有问题了！<br>
3、机械臂的MoveIt!终于可以与RobotHW程序连在一起了。<br>

**问题：**<br>
1、我发现在新写的RobotHW的launch文件中载入Controller配置文件时，如果在其中指定了机器人的namespace后，RobotHW程序就没有办法注册Controller。上网搜了Google一下，发现问题的原因是Controller与RobotHW不在同一个namespace空间下。如何解决，还需研究。<br>
2、之前我在配置机器人的MoveIt!的时候，我是没有办法通过用鼠标直接拖动其在rviz中移动的，不知道什么原因。<br>
3、MoveIt!中的机器人关节方向与实物的并不相符，需要进行一点的转换。<br>

**解决：**<br>
1、这个问题的解决办法其实很简单，只要在RobotHW中，把Controller Manager的NodeHandle中的namespace指定成与Controller配置文件中一样的就可以了。<br>
2、学弟解决了这个问题。首先在MoveIt!生成的joint_limits.yaml文件中添加关节限制，并且在启动完rviz之后，在Kinematics中点中"Allow Approximate IK Solutions"就可以移动末端位置，但是会出现"Query Goal State"与末端脱离的现象，还需改进。<br>

**计划：**<br>
1、尽力解决现在出现的问题。<br>
2、配置好Gazebo中的Kinect插件，并可以通过MoveIt!中的插件来仿真简单的带碰撞的运动规划。<br>

---
## 2016.4.13-4.14

**完成：**<br>
1、通过添加Gazebo中的Plugin实现了点云数据的仿真输出，并且可以使用MoveIt!中的OctoMap来做机械臂的路径避障。<br>
2、实现机械臂在Gazebo中的遥控。<br>

**问题：**<br>
1、我在Gazebo的URDF文件中给Kinect配置Plugin的时候，发现在设置完标签为camera后，总是会发生无法生成URDF的错误。错误内容是"xacro.XacroException: Parameters {Parent, name, color} were not set for macro camera"。<br>
2、我在配置完Kinect的Gazebo插件后，发现生成的点云数据是没有问题的，但其在rviz中的位置却很怪异。它并不在Kinect的正前方，而是经过了两次坐标旋转之后出现在了机器人的右方。<br>

**解决：**<br>
1、我研究了一段时间之后，终于知道导致这个问题出现的原因是什么了。因为xmbot的URDF中有一个camera，而我是用Xacro的方式改写了原先的camera部分，Xacro的名字恰好就叫camera，我把camera的宏名字改成其他的就没有问题了。看来在给Xacro模块起名字的时候，不能用URDF中已存在的关键字。<br>
2、造成这个问题的原因是Kinect本身的坐标轴与Plugin的不一致，解决的办法是在Kinect的基础上再定义一个虚拟的Link，并且通过适当关节的旋转使其与Plugin自身的坐标相吻合。最后在Gazebo的URDF配置文件中，修改frameName为新定义的虚拟Link就可以了。<br>

**计划：**<br>
1、简单学习MoveIt!中的一些API并实现xmbot机械臂规划控制程序。<br>
2、调试实物机械臂，代码有不足要尽可能快速地解决。<br>

---
## 2016.4.23

**完成：**<br>
1、完成了目前我能搞定的机械臂代码，虽然代码不多，但很规范。<br>
2、拍了学弟们调试xmbot的视频，主要有机械臂抓取测试和跟随项目。<br>

**计划：**<br>
1、把自己重新写的机械臂代码传到自己的GitHub仓库中。<br>
2、根据Google代码规范和ROS开发规范，制订自己团队的开发规范。<br>
3、优化xmbot整体和机械臂模块架构图。<br>
4、写xmbot比赛与开发总结。<br>
5、如果还有时间，把调试视频剪辑一下，做一个完整的demo。<br>

---
## 2016.4.30-5.5

**完成：**<br>
1、团队的开发规范已经完成。总共有四份，分别是C++、Python、ROS和GitHub使用风格指南。<br>
2、我重写的机械臂代码应经更新到GitHub上了。<br>

**问题：**<br>
1、机械臂代码还有一些小问题，需要及时地更正。<br>

**计划：**<br>
1、重新规划和设计xmbot的整体和机械臂架构图。<br>
2、写技术总结和个人总结。<br>

---
## 2016.5.6-5.9

**完成：**<br>
1、xmbot整体的系统架构图和机械臂软件架构图。<br>
2、技术总结和个人总结。<br>

**总结：**<br>
1、代码和文档我都写好了，我在组内的任务也基本算是完成了。希望以上的内容可以作为新队员遇到问题的一个参考吧。<br>
2、虽然有关xmbot项目的开发日志到这里基本可以算是结束了，但并不意味着这篇文章在未来就不会再更新了。我相信如果以后我还有机会再去搞ROS机器人方面的研究的话，这份开发日志还能继续记录着开发过程中的点点滴滴。<br>
3、最后，希望看到这篇日志的ROS开发者们也能跟我一样，把开发过程中最重要的东西记录下来。我想，若干年之后，就算各位不再研究ROS，但至少还可以有这么一篇不错的文章供我们回忆起曾经的那些开发岁月。<br>
